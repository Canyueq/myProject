# 1.26

## 配置package.json

使用dev作为启动前后端时不能使用&&连接，因为&&是顺序执行，而前后端都是长期进行的任务，所以不会执行下一个

### 解决方案下载concurrently

```
pnpm install -g concurrently
# 或者在项目中安装
pnpm install --save-dev concurrently
```

修改package.json

```json
"scripts": {
  "dev:frontend": "cd apps/frontend && ppnpm dev",
  "dev:backend": "cd apps/backend && go run main.go",
  "dev": "concurrently \"ppnpm dev:frontend\" \"ppnpm dev:backend\""
}
```

## 前后端json序列化

前端传的格式是小驼峰，后端需要的是蛇形
选择通过前端的拦截器进行参数装换

### 解决方案下载轻量转换工具humps

```pnpm
ppnpm install humps
```

## 接口url

### 前端

前端请求时5713
启动项显示5714
axios配置是8080
发现因为使用转换工具直接使用config作为参数，导致config的baseurl被破坏没有生效

## 跨域

### 因为前端是5714后端是8080所有会产生跨域

解决方案，后端创建跨域中间件

```go
go get github.com/rs/cors
```

## 连接pg数据库

```go
go get -u github.com/lib/pq
```

### 保存环境变量

go需要安装具体包才能读取到.env文件信息

```
go get github.com/joho/godotenv
```

通过保存在.env文件中保存（和编辑系统环境变量不是一个东西）仅用于当前项目读取.作用是提高安全系数

```
DATABASE_URL=host=localhost port=5432 user=postgres dbname=mydb
PORT=8080
```

### 无法打开数据库

未导入连接资源

```
_ "github.com/lib/pq"
```

### 无法连接数据库

需要在.env里至少配置好：

用户名，密码，数据库名称，端口号，主机，ssl模式

user password dbname port host sslmodel

## 用户，连接名，用户名的关系

用户是独立账号，用户名就是用户的名称

连接名仅用于说明连接的名称

用当前系统账户访问，用户就会显示账户名称

第一个代表用户名称，第二个代表数据库名称，如果不写两个name都    会访问当前系统用户名

```
psql -U username-d databasename
```

### 通过**GORM**进行sql操作

```
go get -u gorm.io/gorm
go get gorm.io/driver/postgres
```

mysql数据库连接字符串 (格式: user:password@tcp(host:port)/dbname?charset=utf8mb4&parseTime=True)

```
  dsn := "user:123456@tcp(localhost:5432)/can-yue?"
```

 pg数据库连接

```
dsn := "host=localhost user=canyue password=123456 dbname=can-yue port=5432 sslmode=disable TimeZone=Asia/Shanghai"
```

#### CRUD

```
// 推荐：让 GORM 自动推断表名
db.Where("name = ?", "Alice").Find(&User{})        // 查询
db.Create(&User{Name: "Bob"})                      // 插入
```

## 后端没有返回结果

![](C:\Users\canyue\AppData\Roaming\marktext\images\2026-01-26-22-54-41-image.png)

因为ShouldBind绑定太晚了，导致的

### gin的隐式推断表名通过将结构体名称（首字母大写）转换为复数形式的小写字符串**。

# 1.29

## [**基于物理的渲染**](https://en.wikipedia.org/wiki/Physically_based_rendering) （PBR）

MeshStandardMaterial

physicallyCorrectLights已在 Three.js r155+ 版本中被移除

现在renderer默认开启显示物理光照|不能关闭，也不应该关闭

## DirctionLight

定向光源

```
function createLights() {
  // Create a directional light
  //创建定位灯光，传入颜色和光强
  const light = new DirectionalLight("white", 8);

  //设置灯源位置
  light.position.set(10, 10, 10);

  return light;
}
```

## 材质

MeshBasicMaterial，不具有现实效果的材质

MeshStandardMaterial,基于物理效果的材质

## 解耦main函数

将初始化world和渲染分布进行，可以方便操纵

## World类

通过私有化成员属性的方式，方便回收

```
class World {
  private camera: PerspectiveCamera;
  private renderer: WebGLRenderer;
  private scene: Scene<Object3DEventMap>;
  private cube: Mesh; // ✅ 添加类型
  private light: Light; // ✅ 添加类型
  private resizer: Resizer;
  constructor(
    container: HTMLElement,
    lightPositon?: Position,
    rotation?: Position,
  ) {
    this.camera = createCamera();
    this.scene = createScene();
    this.renderer = createRenderer();
    container.append(this.renderer.domElement);
    this.scene.background = new Color("red");
    this.cube = createCube(lightPositon);
    this.light = createLights(lightPositon);

    this.scene.add(this.cube, this.light);

    this.resizer = new Resizer(container, this.camera, this.renderer);
    // Set the camera's aspect ratio to match the container's proportions
    this.camera.aspect = container.clientWidth / container.clientHeight;

    // next, set the renderer to the same size as our container element
    this.renderer.setSize(container.clientWidth, container.clientHeight);

    // finally, set the pixel ratio to ensure our scene will look good on mobile devices
    this.renderer.setPixelRatio(window.devicePixelRatio);
  }

  render() {
    this.renderer.render(this.scene, this.camera);
  }

  dispose() {
    // 1. 从场景中移除对象
    this.scene.remove(this.cube, this.light);

    // 2. 从 DOM 中移除 renderer 的 canvas
    if (this.renderer.domElement.parentNode) {
      this.renderer.domElement.parentNode.removeChild(this.renderer.domElement);
    }

    // 4. 释放 Three.js 资源
    this.renderer.dispose(); // 释放 WebGL 上下文

    // 5. 释放几何体和材质（防止 GPU 内存泄漏）
    this.cube.geometry.dispose();

    // 6. （可选）如果 light 有自定义资源，也清理（通常不需要）

    // 7. 断开引用（帮助 GC）
    this.camera = null!;
    this.renderer = null!;
    this.scene = null!;
    this.cube = null!;
    this.light = null!;
    this.resizer = null!;
  }
}
```

### 位置，旋转，拉伸

position,rotation,scale

### 每个场景（scene）和网格（mesh）分别都代表了一个 坐标系

```
// A starts at (0,0,0) in world space
scene.add(meshA);

// B starts at (0,0,0) in A's local space
meshA.add(meshB);

meshA.position.x = 5;

meshB.position.x = 3;
```

每个对象最开始的位置都是相对于父对象的（0，0，0）

所以mesha的坐标是（5，0，0）meshb的坐标是（8，0，0）

## 相机

- X轴正向指向屏幕 *右侧*。

- Y轴正向指向屏幕 *上方*，即屏幕顶部。

- Z轴正向指向屏幕 *外面*，即指向屏幕前的你。

- ![世界空间内的方向](https://discoverthreejs.com/images/first-steps/coordinate_system.svg)

## Vector3

用于存储位置的容器

.position和.scale都是Vector3的实例

这表示他们的属性是Vector类，但是具体功能要绑定positon或者scale才能体现出来

```
const vector = new Vector(1,1,1)
```

构造参数默认是0,0,0用于表示x,y,z的缩放比例或位置信息,缩放默认是1

## Euler

用于存储位置的容器

.rotation

```
const euler = new Euler()
```

构造参数默认是0,0,0用于表示x,y,z的旋转轴。参数是弧度制

可以用以下方法从角度转换为弧度

```
import { MathUtils } from 'three';

const rads = MathUtils.degToRad(90); // 1.57079... = π/2
```

### 另一个旋转类：四元数Quaternions

这两个都哦用于表示旋转，一个改变另一个也会改变成对应形式

## 矩阵 matrix

### 三阶矩阵 matrix3

### 四阶矩阵 matrix4

每个Vcoter和Euler都是1*3的矩阵，三个合在一起就是一个三阶矩阵。能极大的提升效率。每个Vcoter和Euler被称为局部矩阵存储在matrix属性上

#### 由于rotation默认是1，其余都默认是0那么默认matrix：

```
1,0,0,0
0,1,0,0
0,0,1,0
0,0,0,1
```

![](C:\Users\canyue\AppData\Roaming\marktext\images\2026-01-29-16-35-21-image.png)

position存储在matrix的最后一列,scale存储在matrx的对角线

```
ex,0,0,px
0,ey,0,py
0,0,ez,pz
0,0,0,1
```

**上面提到的父子对象坐标系规则就是把相应的matrix相加**即：

```
1,0,0,5        
0,1,0,0    +    (3,0,0)=
0,0,1,0
0,0,0,1
```

后者被称为世界矩阵，前者是局部矩阵。当直接作用于场景的对象，世界矩阵等于局部矩阵。不直接作用于场景的对象，需要进行运算

#### rotation的矩阵部分较难

把负责rotation的部分看作三阶矩阵，x是右下的二阶矩阵，y是三阶矩阵的四个顶点，z是左上的二阶矩阵

```
cy cz,sz,sy
-sz,czcx,sx
-sy,-sx,cxcy
```



![](C:\Users\canyue\AppData\Roaming\marktext\images\2026-01-29-16-29-24-image.png)

**light只有position，camera没有scale**


